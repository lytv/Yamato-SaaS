/**
 * Excel Helper Functions
 * Following TypeScript Type Safety Standards
 * Generates Excel files for product export functionality
 */

import type { Buffer } from 'node:buffer';

import * as XLSX from 'xlsx';

import type { Product } from '@/types/product';
import type { ProductionStep } from '@/types/productionStep';

/**
 * Generate Excel workbook from products array
 * @param products - Array of products to export
 * @returns Buffer containing Excel file data
 */
export function generateProductsExcel(products: readonly Product[]): Buffer {
  // Create a new workbook
  const workbook = XLSX.utils.book_new();

  // Transform products data for Excel export
  const excelData = products.map(product => ({
    'Product Code': product.productCode,
    'Product Name': product.productName,
    'Category': product.category || '',
    'Notes': product.notes || '',
    'Created Date': formatDateForExcel(product.createdAt),
    'Updated Date': formatDateForExcel(product.updatedAt),
  }));

  // Create worksheet from data
  const worksheet = XLSX.utils.json_to_sheet(excelData);

  // Set column widths for better readability
  const columnWidths = [
    { wch: 15 }, // Product Code
    { wch: 30 }, // Product Name
    { wch: 20 }, // Category
    { wch: 40 }, // Notes
    { wch: 12 }, // Created Date
    { wch: 12 }, // Updated Date
  ];
  worksheet['!cols'] = columnWidths;

  // Add metadata sheet with export information
  const metadataSheet = XLSX.utils.json_to_sheet([
    { Field: 'Export Date', Value: new Date().toISOString() },
    { Field: 'Total Products', Value: products.length },
    { Field: 'Generated By', Value: 'Yamato SaaS Product Management' },
  ]);

  // Add sheets to workbook
  XLSX.utils.book_append_sheet(workbook, worksheet, 'Products');
  XLSX.utils.book_append_sheet(workbook, metadataSheet, 'Export Info');

  // Generate buffer
  const excelBuffer = XLSX.write(workbook, {
    type: 'buffer',
    bookType: 'xlsx',
    compression: true,
  });

  return excelBuffer;
}

/**
 * Generate Excel workbook from production steps array
 * @param productionSteps - Array of production steps to export
 * @returns Buffer containing Excel file data
 */
export function generateProductionStepsExcel(productionSteps: readonly ProductionStep[]): Buffer {
  // Create a new workbook
  const workbook = XLSX.utils.book_new();

  // Transform production steps data for Excel export
  const excelData = productionSteps.map(step => ({
    'Step Code': step.stepCode,
    'Step Name': step.stepName,
    'Film Sequence': step.filmSequence || '',
    'Step Group': step.stepGroup || '',
    'Created Date': formatDateForExcel(step.createdAt),
    'Updated Date': formatDateForExcel(step.updatedAt),
  }));

  // Create worksheet from data
  const worksheet = XLSX.utils.json_to_sheet(excelData);

  // Set column widths for better readability
  const columnWidths = [
    { wch: 15 }, // Step Code
    { wch: 30 }, // Step Name
    { wch: 15 }, // Film Sequence
    { wch: 20 }, // Step Group
    { wch: 12 }, // Created Date
    { wch: 12 }, // Updated Date
  ];
  worksheet['!cols'] = columnWidths;

  // Add metadata sheet with export information
  const metadataSheet = XLSX.utils.json_to_sheet([
    { Field: 'Export Date', Value: new Date().toISOString() },
    { Field: 'Total Production Steps', Value: productionSteps.length },
    { Field: 'Generated By', Value: 'Yamato SaaS Production Management' },
  ]);

  // Add sheets to workbook
  XLSX.utils.book_append_sheet(workbook, worksheet, 'Production Steps');
  XLSX.utils.book_append_sheet(workbook, metadataSheet, 'Export Info');

  // Generate buffer
  const excelBuffer = XLSX.write(workbook, {
    type: 'buffer',
    bookType: 'xlsx',
    compression: true,
  });

  return excelBuffer;
}

/**
 * Format date for Excel display
 * @param date - Date string or Date object
 * @returns Formatted date string
 */
function formatDateForExcel(date: string | Date): string {
  const dateObj = new Date(date);

  if (Number.isNaN(dateObj.getTime())) {
    return '';
  }

  return dateObj.toLocaleDateString('en-US', {
    year: 'numeric',
    month: '2-digit',
    day: '2-digit',
  });
}

/**
 * Generate filename for Excel export
 * @param prefix - Filename prefix (default: 'products-export')
 * @returns Filename with timestamp
 */
export function generateExcelFilename(prefix: string = 'products-export'): string {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
  return `${prefix}-${timestamp}.xlsx`;
}

/**
 * Validate Excel export data
 * @param products - Products array to validate
 * @returns Validation result
 */
export function validateExcelExportData(products: readonly Product[]): {
  isValid: boolean;
  error?: string;
} {
  if (!Array.isArray(products)) {
    return { isValid: false, error: 'Products must be an array' };
  }

  if (products.length === 0) {
    return { isValid: false, error: 'No products to export' };
  }

  if (products.length > 5000) {
    return { isValid: false, error: 'Too many products to export (maximum 5000)' };
  }

  // Check if products have required fields
  const invalidProducts = products.filter(
    product => !product.productCode || !product.productName,
  );

  if (invalidProducts.length > 0) {
    return {
      isValid: false,
      error: `${invalidProducts.length} product(s) missing required fields`,
    };
  }

  return { isValid: true };
}

/**
 * Validate ProductionStep export data
 * @param productionSteps - ProductionSteps array to validate
 * @returns Validation result
 */
export function validateProductionStepExportData(productionSteps: readonly ProductionStep[]): {
  isValid: boolean;
  error?: string;
} {
  if (!Array.isArray(productionSteps)) {
    return { isValid: false, error: 'Production steps must be an array' };
  }

  if (productionSteps.length === 0) {
    return { isValid: false, error: 'No production steps to export' };
  }

  if (productionSteps.length > 5000) {
    return { isValid: false, error: 'Too many production steps to export (maximum 5000)' };
  }

  // Check if production steps have required fields
  const invalidSteps = productionSteps.filter(
    step => !step.stepCode || !step.stepName,
  );

  if (invalidSteps.length > 0) {
    return {
      isValid: false,
      error: `${invalidSteps.length} production step(s) missing required fields`,
    };
  }

  return { isValid: true };
}
